import numpy as np
from scipy.interpolate import RectBivariateSpline

# =============================================================================
# CONSTANTS

kB = 1.38064852e-23     # Boltzmann's constant (J/K)
# =============================================================================



def generateMBvelocity(mass, temp):
# =============================================================================
# Returns a velocity sampled from the Maxwell-Boltzmann distribution
# Inputs:
#   1) mass = mass of the atom   
#   2) temp = temperature of the atoms
# =============================================================================
        
    mu = 0
    sigma = np.sqrt(kB*temp/mass)
    return np.random.normal(mu, sigma,1)
    
def maxwellBoltzmann3D(mass, temp, vel):
# =============================================================================
# Returns the 3D Maxwell-Boltzmann probability distribution for a given velocity
# Inputs:
#   1) mass = mass of the atom   
#   2) temp = temperature of the atoms
#   3) vel  = array of velocities to calculate the MB distribution at
# =============================================================================
    a = np.sqrt(kB*temp/mass)
    f = ((1/2/np.pi/(a**2))**(3/2))*(4*np.pi*vel**2)*np.exp(-0.5*(vel/a)**2)
    return f

def maxwellBoltzmann2D(mass, temp, vel):
# =============================================================================
# Returns the 2D Maxwell-Boltzmann probability distribution for a given velocity
# Inputs:
#   1) mass = mass of the atom   
#   2) temp = temperature of the atoms
#   3) vel  = array of velocities to calculate the MB distribution at
# =============================================================================
    a = np.sqrt(kB*temp/mass)
    f = (vel/a**2)*np.exp(-0.5*(vel/a)**2)
    return f

# =============================================================================
# Using the RK4 method to solve the equations of motion for a general force F
def f(t,y,v):
    return v
# for solving v'(t) = y''(t) = -omega^2 y(t) = f2(t,y,v)
def g(t,y,v,force,mass,ypos):
    return force[findNearest(ypos, y)]/mass

def RK4(y, v, t, h, force, mass, ypos):    
    r1 = f(t,y,v)
    k1 = g(t,y,v,force,mass,ypos)
    r2 = f(t+h/2,y+(h*r1)/2,v+(h*k1)/2)
    k2 = g(t+h/2,y+(h*r1)/2,v+(h*k1)/2,force,mass,ypos)
    r3 = f(t+h/2,y+(h*r2)/2,v+(h*k2)/2)
    k3 = g(t+h/2,y+(h*r2)/2,v+(h*k2)/2,force,mass,ypos)
    r4 = f(t+h,y+(h*r3),v+(h*k3))
    k4 = g(t+h,y+(h*r3),v+(h*k3),force,mass,ypos)

    y_next = y + (h/6)*(r1 + 2*r2 + 2*r3 + r4)
    v_next = v + (h/6)*(k1 + 2*k2 + 2*k3 + k4)
    t_next = t + h
    return y_next, v_next, t_next

# =============================================================================

# =============================================================================
# Using the RK4 method to solve the simple harmonic oscillator
def shof1(t,y,v):
    return v
# for solving v'(t) = y''(t) = -omega^2 y(t) = f2(t,y,v)
def shof2(t,y,v,omega0):
    return -(omega0**2) * y

def shoRK4(y, v, t, h, omega0):
    r1 = shof1(t,y,v)
    k1 = shof2(t,y,v,omega0)
    r2 = shof1(t+h/2,y+(h*r1)/2,v+(h*k1)/2)
    k2 = shof2(t+h/2,y+(h*r1)/2,v+(h*k1)/2,omega0)
    r3 = shof1(t+h/2,y+(h*r2)/2,v+(h*k2)/2)
    k3 = shof2(t+h/2,y+(h*r2)/2,v+(h*k2)/2,omega0)
    r4 = shof1(t+h,y+(h*r3),v+(h*k3))
    k4 = shof2(t+h,y+(h*r3),v+(h*k3),omega0)

    y_next = y + (h/6)*(r1 + 2*r2 + 2*r3 + r4)
    v_next = v + (h/6)*(k1 + 2*k2 + 2*k3 + k4)
    t_next = t + h
    return y_next, v_next, t_next

def sho_energy(m, omega, y, v):
    return (1/2)*m*(omega*y)**2 + (1/2)*m*v**2

# =============================================================================

# =============================================================================
# Function used to interpolate the acz potential generated by the matlab gui to a finer grid specified by numpoints
def interpolatePotential(x,y,U,numpoints):
    X, Y = np.meshgrid(x, y)

    interp_spline = RectBivariateSpline(y, x, U)


    x2 = np.linspace(x[0],x[-1],numpoints)
    y2 = np.linspace(y[0],y[-1],numpoints)
    X2, Y2 = np.meshgrid(x2,y2)
    Uinterp = interp_spline(y2, x2)
    return Uinterp, x2, y2
# =============================================================================

# =============================================================================
# Take the gradient of the potential to give a force
def gradientPotential(U,x,y):
    
    # get the spacing between points. Assume an equally spaced grid
    dy = y[1]-y[0]
    dx = x[1]-x[0]
    
    # take the gradient and add a minus sign to get the force
    ygrad, xgrad = np.gradient(U, dy, dx)
    Fx = -xgrad
    Fy = -ygrad
    return Fx[0,:], Fy[:,0]

def gradientPotential2(U,x,y):
    
    # get the spacing between points. Assume an equally spaced grid
    dy = y[1]-y[0]
    dx = x[1]-x[0]
    
    # take the gradient and add a minus sign to get the force
    ygrad, xgrad = np.gradient(U*kB/1e6, dy, dx)
    Fx = -xgrad
    Fy = -ygrad
    return Fx, Fy
# =============================================================================

# =============================================================================
# returns the index of arr closest to val
def findNearest(arr, val):
    diff = np.absolute(arr - val)
    idx = diff.argmin()
    return idx
# =============================================================================



def calcCutoff(trapDepth, trapFreq):
    m = 1.44316060e-25       # mass of rubidium 87 (kg)
    kB = 1.38064852e-23      # Boltzmann's constant (J/K)
    
    return np.sqrt(2*kB*trapDepth/1e6/m/((2*np.pi*trapFreq)**2))


def checkInTrap(x,y,Fx,Fy):
    if np.sign(Fx)/np.sign(x) > 1 or np.sign(Fy)/np.sign(y) > 1:
        return False
    else:
        return True





    
